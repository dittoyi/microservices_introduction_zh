# 构建微服务：进程间通信

这是我们关于使用微服务架构构建应用程序的第三篇文章。 第一篇文章介绍了微服务模式，将其与单体模式进行比较，并讨论了使用微服务的优点和缺点。 第二篇文章描述了客户端如何通过被称为API网关的中介与微服务通信。 在本文中，我们将了解系统中的服务之间如何相互通信。 第四篇文章探讨了密切相关的服务发现问题。

## 介绍

在单体应用程序中，组件通过语言级方法或函数互相调用。 相比之下，基于微服务的应用程序是在多台机器上运行的分布式系统。 每个服务实例通常是一个进程。 因此，如下图所示，服务必须使用进程间通信（IPC）机制进行交互。

![diagram](https://cdn.wp.nginx.com/wp-content/uploads/2015/07/Richardson-microservices-part3-monolith-vs-microservices-1024x518.png)

稍后我们将讨论具体的IPC技术，但首先让我们探讨各种设计问题。

## 交互风格

当为服务选择IPC机制时，首先考虑服务是如何交互的是有用的。 有各种client⇔service交互风格。 它们可以归类为两个维度。 第一个维度是，他们是一对一还是一对多的：

* 一对一 - 每个客户端请求都由一个服务实例处理。
* 一对多 - 每个客户端请求都由多个服务实例处理。

第二个维度是，交互是同步还是异步的：

* 同步 - 客户端期望来自服务的及时响应，并且在等待过程中阻塞。
* 异步 - 客户端在等待响应时不阻塞，并且响应（如果有的话）不一定立即发送。

下表显示了各种交互方式。

|           |    一对一          |     一对多          |
|-----------|:-------------------|--------------------|
|同步       |请求/响应            |-                    |
|异步       |通知                |发布/订阅             |
|           |请求/异步响应        |发布/异步响应         |

有以下几种的一对一交互方式：

* 请求/响应 - 客户端向服务器发出请求并等待响应。 客户期望响应及时到达。 在基于线程的应用程序中，发出请求的线程可能在等待时阻塞。
* 通知（也称为单向请求） - 客户端向服务器发送请求，但不期望回复。
* 请求/异步响应 - 客户端向服务发送请求，服务异步响应。 客户端在等待时不阻塞，设计时假设响应在一段时间内不会到达。

有以下几种的一对多交互方式：

* 发布/订阅 - 客户端发布通知消息，由零个或多个感兴趣的服务消费。
* 发布/异步响应 - 客户端发布通知消息，然后等待一定时间以接受服务的响应。

每个服务通常使用这些交互风格的组合。 对于某些服务，单个IPC机制就足够了。 其他服务可能需要使用IPC机制的组合。 下图显示了当用户请求旅行时，出租汽车应用程序中的服务如何交互。

![diagram](https://cdn.wp.nginx.com/wp-content/uploads/2015/07/Richardson-microservices-part3-taxi-service-1024x609.png)

服务使用通知，请求/响应和发布/订阅的组合。 例如，乘客的智能电话向旅行管理服务发送通知以请求接送。 旅行管理服务通过使用请求/响应来调用旅客服务来验证旅客的帐户是否有效。 旅行管理服务然后创建旅行，并使用发布/订阅来通知其他服务，包括调度服务，来定位附近的司机。

现在我们已经看了交互样式，让我们来看看如何定义API。

## 定义API

服务的API是服务与其客户之间的契约。 无论您选择何种IPC机制，使用某种接口定义语言（IDL）精确定义服务的API非常重要。 有很多关于以API优先来定义服务的争论。 您的开发任务从接口定义开始，然后与客户端开发人员一起审查。 只有在对API定义进行迭代之后，才开始服务的真正编码工作。 在编码之前进行此设计，可以保证您的服务更好的满足其客户需求。

正如你将在本文后面看到的，API定义的本质取决于你使用的具体IPC机制。 如果您使用消息传递，API由消息通道和消息类型组成。 如果您使用HTTP，API由URL、请求和响应格式组成。 稍后我们将更详细地描述一些IDL。

## API演化

服务的API总是随时间变化。在单体应用程序中，通常可以直接更改API并更新所有调用者。在基于微服务的应用程序中，则困难很多，即使你的API的所有消费者都位于同一个应用中。通常，您不能强制所有客户端与服务一起同步升级。此外，您可能会逐步部署新版本的服务，以使旧版本和新版本的服务将同时运行。有一个处理这些问题的策略是很重要的。

如何处理API更改取决于更改的大小。一些更改是轻微的，向后兼容以前的版本的。例如，您可能在请求或响应中添加新属性。设计客户端和服务以使其遵守鲁棒性原则是有意义的。使用旧API的客户端应该可以使用新版本的服务。服务应该为请求中缺失的参数提供默认值，并且客户端应该忽略任何额外的响应属性。重要的是，你应该采用一种IPC机制和消息传递格式，使您能够轻松地改进您的API。

然而，有时，您必须对API进行主要的，不兼容的更改。由于您无法强制客户端立即升级，因此服务必须在一段时间内支持API的旧版本。如果您使用基于HTTP的机制（如REST），一种方法是在URL中嵌入版本号。每个服务实例可能同时处理多个版本。或者，您可以部署各自处理特定版本的不同实例。

## 处理分区故障

如上一篇关于API网关的文章所述，在分布式系统中，永远存在分区故障的风险。 由于客户端和服务在分隔的进程中，因此服务可能无法及时响应客户端的请求。 由于故障或维护，服务可能会关闭。 或者服务可能过载从而对导致响应请求非常缓慢。

例如，考虑上篇文章中的产品详细信息场景。 让我们假设推荐服务没有响应。 一个幼稚的客户端实现可能会无限期地等待下去。 这不仅会导致糟糕的用户体验，而且许多应用程序中，它会消耗宝贵的资源，如线程。 最终，运行时将耗尽线程池而无法响应，如下图所示。

![diagram](https://cdn.wp.nginx.com/wp-content/uploads/2015/07/Richardson-microservices-part3-threads-blocked-1024x383.png)

为了防止这种问题，你需要设计你的服务来处理这种故障。

Netflix介绍了一种很好的方法。这个处理分区故障的策略包括：

* 网络超时 - 不要无限期地阻塞，在等待响应时始终使用超时机制。使用超时可确保资源不会永远的捆绑。
* 限制未完成请求的数量 - 对特定服务为客户端可以拥有的未完成请求数量施加上限。如果已达到限制，则进行更多的请求很可能是无意义的，这些尝试需要立即失败。
* 断路器模式 - 跟踪成功和失败请求的数量。如果错误率超过配置的阈值，打开断路器以使后续的尝试立即失败。如果大量请求失败，则表明服务不可用，并且发送请求是无意义的。超时时间过后，客户端应再次尝试，如果成功，就关闭断路器。
* 提供回退 - 请求失败时执行回退逻辑。例如，返回缓存数据或默认值（如空的推荐集）。

[Netflix Hystrix](https://github.com/Netflix/Hystrix)是一个实现这些和其他模式的开源库。 如果你使用JVM，你一定要考虑使用Hystrix。 如果您在非JVM环境中运行，则应使用一个等效库。

## IPC技术

有很多不同的IPC技术可供选择。 服务可以使用同步的基于请求/响应的通信机制，例如基于HTTP的REST或Thrift。 或者，可以使用异步的基于消息的通信机制，例如AMQP或STOMP。 还有各种不同的消息格式。 服务可以使用可读的基于文本的格式，例如JSON或XML。 或者，可以使用二进制格式（更高效），如Avro或Protocol Buffers。 稍后我们将讨论同步的IPC机制，但首先让我们讨论异步的IPC机制。

### 异步，基于消息的通信

当使用消息传递时，进程异步地交换消息进行通信。客户端通过向服务发送消息向服务发出请求。如果服务期望回复，它通过发送单独的消息返回给客户端进行响应。由于通信是异步的，所以客户端不会阻塞等待应答。相反，客户端是假设不会立即接收到答复来进行设计的。

一条消息通常由消息头（诸如发送者的元数据）和消息主体组成。消息通过通道交换。任何数量的生产者可以向一个通道发送消息。类似地，任何数量的消费者可以从通道接收消息。有两种类型的通道，点对点和发布-订阅。点对点通道将消息发送给正在读取的任意一个消费者。服务使用点对点通道实现前面描述的一对一交互风格。发布-订阅通道将每个消息传递给所有订阅的消费者。服务使用发布-订阅通道来实现上述的一对多交互方式。

下图显示了出租汽车应用程序如何使用发布-订阅通道。

![diagram](https://cdn.wp.nginx.com/wp-content/uploads/2015/07/Richardson-microservices-part3-pub-sub-channels-1024x639.png)

旅行管理服务通过向发布-订阅通道写入“旅行已创建”消息来通知感兴趣的服务，例如调度服务，一个旅行已创建。 调度服务找到一个可用的司机，并通过向发布-订阅通道写入一个“找到推荐司机”消息来通知其他服务。

有许多消息系统可供选择。 你应该选择一个支持各种编程语言的。 一些消息系统支持标准协议，如AMQP和STOMP。 其他消息系统具有专有的文档化的协议。 有大量的开源消息系统可供选择，包括RabbitMQ，Apache Kafka，Apache ActiveMQ和NSQ。 在高层面，他们都支持某种形式的消息和通道。 他们都力求可靠，高可用和可扩展性。 然而，每个代理的消息传递模型的细节存在显着差异。

使用消息传递有很多好处：

* 将客户端与服务解耦 - 客户端通过向相应的通道发送消息来发出请求。客户端完全不知道服务实例。它不需要使用发现机制来确定服务实例的位置。
* 消息缓冲 - 使用同步的请求/响应协议（如HTTP），客户端和服务都必须在通信期间可用。相反，消息代理则将消息写入通道的消息队列，直到消费者可以处理它们。这意味着，例如，即使在订单执行系统较慢或不可用时，在线商店也可以接受来自客户的订单。订单消息只是简单的排队。
* 灵活的客户端-服务交互 - 消息支持前面讨论的所有交互风格。
* 显式的进程间通信 - 基于RPC的机制试图使调用远程服务看起来与调用本地服务相同。然而，由于物理定律和分区失效的可能性，它们实际上是完全不同的。消息传递使得这些差异非常明确，因此开发人员不会陷入虚假的安全感。

但是，使用消息传递也有一些缺点：

* 操作更加复杂 - 消息系统是必须安装，配置和操作的另一个系统组件。 消息代理必须高度可用，否则系统可靠性会受到影响。
* 实现基于请求/响应的交互更加复杂 - 请求/响应式风格的交互需要一些额外工作来实现。 每个请求消息必须包含回复信道标识符和相关标识符。 服务将包含关联ID的响应消息写入回复通道。 客户端使用关联ID将响应与请求进行匹配。 使用直接支持请求/响应模式的IPC机制来实现通常更容易。

现在我们已经研究了使用基于消息的IPC，让我们检查基于请求/响应的IPC。

### 同步，基于请求/响应的通信

当使用同步的，基于请求/响应的IPC机制时，客户端向服务发送请求。服务处理请求并发回响应。在许多客户端中，发送请求的线程将阻塞并等待响应。其他客户端可能使用异步的，事件驱动的客户端代码，可能由Futures或Rx Observables封装。但是，与使用消息传递不同，客户端假设响应将及时到达。有很多协议可供选择。两种流行的协议是REST和Thrift。让我们先来看看REST。

#### REST

今天，以RESTful风格开发API很时尚。 REST是一种（几乎总是）基于HTTP的IPC机制。 REST中的一个关键概念是资源，它通常表示业务对象（如客户或产品）或业务对象集合。 REST使用在URL中包含的HTTP动词来处理资源。例如，GET请求返回资源的表示形式，它可能是XML文档或JSON对象的形式。 POST请求创建一个新资源，PUT请求更新资源。引用REST的创建者Roy Fielding的话：

> "REST提供了一套架构约束，当作为整体应用时，强调组件交互的可扩展性，接口的泛用性，组件的独立部署性，以及减少中间件的交互延迟，加强安全性并封装原有系统。"
>
> —- Fielding, [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)

下图显示了出租汽车应用程序可能使用REST的一种方式。

![diagram](https://cdn.wp.nginx.com/wp-content/uploads/2015/07/Richardson-microservices-part3-rest-1024x397.png)

乘客的智能手机通过向旅行管理服务的*/trip*资源发出*POST*请求来请求旅行。 此服务通过向乘客管理服务发送对乘客信息的*GET*请求来处理请求。 在验证乘客被授权创建旅行之后，旅行管理服务创建旅行并且向智能电话返回*201*响应。

许多开发人员声称他们的基于HTTP的API是RESTful的。 但是，正如Fielding在这篇[博客](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)中描述的，并不是所有的都是。 Leonard Richardson定义了一个非常有用的REST成熟度模型，由以下级别组成。

* Level 0 - Level 0 的客户端通过向其唯一的URL地址发出*HTTP POST*请求来调用服务。每个请求指定要执行的动作，动作的目标（例如业务对象）和任何参数。
* Level 1 - Level 1 的API支持资源的想法。要对资源执行操作，客户端会发出一个*POST请求*，指定要执行的操作和任何参数。
* Level 2 - Level 2 的API使用HTTP动词执行操作：*GET检索*，*POST创建*，*PUT更新*。请求参数和请求主体（如果有）指定操作的参数。这使服务能够利用Web基础架构，例如为*GET请求*使用缓存。
* Level 3 - Level 3 的API的设计基于HATEOAS（超复杂的命名，Hypertext As The Engine Of Application State，超文本作为应用程序状态引擎）原理。基本思想是由*GET请求*返回资源的表示，并包含该资源允许执行的所有动作。例如，客户端可以使用在获取订单信息的*GET请求*中返回的某个链接来进行取消订单操作。 HATEOAS的好处包括不再需要将URL硬编码到客户端代码中。另一个好处是，因为资源的表示包含所有允许的动作链接，所以客户端不必猜测对其当前状态下的资源可以执行什么动作。

使用基于HTTP的协议有很多好处：

* HTTP简单，熟悉。
* 您可以使用浏览器扩展（如Postman）测试HTTP API，也可以使用curl从命令行测试HTTP API（假设使用JSON或其他文本格式）。
* 它直接支持请求/响应式通信。
* HTTP是防火墙友好的。
* 它不需要中间代理，这简化了系统的架构。

使用HTTP有一些缺点：

* 它只支持请求/响应式的交互。 您可以使用HTTP实现通知机制，但服务器必须始终发送HTTP响应。
* 因为客户端和服务直接通信（没有中间体来缓冲消息），它们都必须在交换期间可用。
* 客户端必须知道每个服务实例的位置（即，URL）。 如上一篇关于API网关的文章所述，这是现代应用程序中的一个非平凡问题。 客户端必须使用服务发现机制来定位服务实例。

开发社区最近在重新探索实现RESTful API的接口定义语言的价值。 有几个选项，包括RAML和Swagger。 一些IDL（如Swagger）允许您定义请求和响应消息的格式。 其他如RAML要求您使用单独的规范，如JSON模式。 除了描述API之外，IDL通常还具有从接口定义生成客户端存根和服务器框架的工具。

#### Thrift

Apache Thrift是REST的一个有趣的替代品。它是一个用于编写跨语言RPC客户端和服务器的框架。 Thrift提供了一个C风格的IDL来定义你的API。您使用Thrift编译器来生成客户端存根和服务器端骨架。编译器生成各种语言的代码，包括C ++，Java，Python，PHP，Ruby，Erlang和Node.js.

Thrift接口由一个或多个服务组成。服务定义类似于Java接口。它是一个强类型方法的集合。 Thrift方法可以返回一个（可能为void）值，也可以定义为单向。返回值的方法实现了请求/响应的交互风格。客户端等待响应，可能会抛出异常。单向方法对应于通知的交互风格。服务器不发送响应。

Thrift支持各种消息格式：JSON，二进制和紧凑二进制。二进制比JSON更高效，因为它解码更快。而且，顾名思义，紧凑二进制是一种节省空间的格式。 JSON，当然，是人类和浏览器友好的。 Thrift还为您提供了选择具体传输协议的机会，包括原始TCP和HTTP。原始TCP可能比HTTP更有效。但是，HTTP是防火墙、浏览器和人类友好的。

### 消息格式

现在我们来看看HTTP和Thrift，让我们来看一下消息格式的问题。 如果您正在使用消息传递系统或REST，你需要选择你的消息格式。 其他IPC机制，如Thrift可能只支持少量的消息格式，也许只有一个。 在任一情况下，使用跨语言消息格式很重要。 即使您今天以单一语言编写您的微服务，未来也有可能使用其他语言。

有两种主要的消息格式：文本和二进制。 基于文本格式的示例包括JSON和XML。 这些格式的优点是，它们不仅是人类可读的，而且是自我描述的。 在JSON中，对象的属性由一组名称 - 值对表示。 类似地，在XML中，属性由命名的元素和值表示。 这使得消息的消费者能够挑选其感兴趣的值并忽略其余值。 因此，对消息格式的微小改变可以容易地向后兼容。

XML文档的结构由XML Schema指定。 随着时间的推移，开发人员社区已经意识到JSON也需要类似的机制。 一个选择是使用JSON Schema，独立或作为IDL的一部分，如Swagger。

使用基于文本的消息格式的缺点是消息往往是冗长的，尤其是XML。 因为消息是自描述的，所以每个消息都包含属性的名称以及它们的值。 另一个缺点是解析文本的开销。 因此，您可能需要考虑使用二进制格式。

有几种二进制格式可供选择。 如果你使用Thrift RPC，你可以使用二进制Thrift。 如果你需要选择消息格式，流行的选项包括Protocol Buffers和Apache Avro。 这两种格式都提供了一个类型化的IDL来定义消息的结构。 然而，一个区别是Protocol Buffers使用标记字段，而Avro消费者需要知道解释消息的schema。 因此，使用Protocol Buffers的API演化比使用Avro更容易。 这篇[博文](http://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html)对Thrift，Protocol Buffers和Avro作了一个很好的比较。

## 总结

微服务必须使用进程间通信机制进行通信。 在设计服务如何进行通信时，您需要考虑各种问题：服务如何交互，如何为每个服务指定API，如何演进API以及如何处理分区故障。 微服务可以使用两种类型的IPC机制，异步消息和同步请求/响应。 在本系列的下一篇文章中，我们将讨论微服务架构中服务发现的问题。
