# 将单体应用重构为微服务

这是我的关于使用微服务构建应用程序系列文章的第七篇及最后一篇文章。第一篇文章介绍了微服务架构模式，并讨论了使用微服务的优点和缺点。后续文章讨论了微服务架构的不同方面：使用API​​网关，进程间通信，服务发现，事件驱动的数据管理和部署微服务。在本文中，我们将讨论将单体应用程序迁移到微服务的策略。

我希望这个系列的文章能使大家很好的理解微服务架构，其优点和缺点，以及何时使用它。也许微服务架构很适合你的团队。

然而，你很有可能正在构建一个大而复杂的单体应用程序。每日开发和部署你的单体应用程序的体验是缓慢而痛苦的。微服务似乎是一个遥远的极乐世界。幸运的是，有一些策略，你可以用来从地狱逃脱。在本文中，我将描述如何将单体应用程序逐步重构为一组微服务。

## 重构到微服务概述

将单体应用程序转换为微服务的过程是应用程序现代化的一种形式。 这是开发人员已经做了几十年的事情。 因此，有一些想法可以在我们重构的过程中借鉴。

有一个策略要避免使用，即“大爆炸”式重写。 即把任务聚焦在从头开始构建一个新的基于微服务的应用程序。 虽然听起来很吸引人，但它是非常危险的，并且很可能会以失败告终。 正如Martin Fowler所说，“大爆炸重写（从头开始构建应用）可以确保的唯一的东西就是大爆炸（灾难）！”

你应该使用递增方式重构你的单体应用程序，而不是从头开始构建。 您可以持续构建一个由微服务组成的新应用程序，并与您的单体应用程序一起运行。 随着时间的推移，由单体应用程序实现的功能量收缩，直到它完全消失或者成为另一个微服务。 这种策略类似于以70英里/小时的速度在高速公路上行驶 - 具有挑战性，但没有尝试从头开始构建的风险。

Martin Fowler将此应用程序现代化策略称为[Strangler Application](https://www.martinfowler.com/bliki/StranglerApplication.html)。 这个名字来源于在热带雨林中发现的扼杀者藤（也称为，绞杀榕）。 扼制者藤蔓生长在一棵树上，以便到达森林树冠上的阳光。 有时，树死了，留下一棵树形的藤。 应用程序现代化遵循相同的模式。 我们在遗留下的程序基础上构建新的微服务组成的程序，而遗留的程序终将死亡。

![diagram](https://cdn.wp.nginx.com/wp-content/uploads/2016/03/Richardson-microservices-part7-fig.png)

让我们看看这样做的不同策略。

## 策略1 - 停止挖掘

霍利斯法则（[Law of Holes](https://en.wikipedia.org/wiki/Law_of_holes)）说，每当你身处洞中，你就应该停止挖掘。 当你的单体应用程序变得难以管理时，这是一个很好的建议。 换句话说，你应该停止使这个东西变得更大。 这意味着当你需要实现新的功能，你不应该在这个东西上添加更多的代码。 相反，这个策略的一个大想法是将这个新代码放在一个独立的微服务中。 下图显示了应用此方法后的系统架构。

![diagram](https://cdn.wp.nginx.com/wp-content/uploads/2016/03/Adding_a_secure_microservice_alongside_a_monolithic_application-1024x865.png)

除了新服务和传统的单体应用外，还有两个其他组件。 第一个是请求路由器，它处理传入的请求（HTTP）。 它类似于前面的文章中描述的API网关。 路由器向新服务发送对应于新功能的请求。 将对应旧功能的请求路由到单体应用。

另一个组件是胶水代码，它将服务与单体应用集成。 服务很少孤立存在，并且通常需要访问单体应用所拥有的数据。 胶水代码，附加在单体应用，服务或两者中，负责数据集成。 新的服务使用胶水代码来读取和写入单体应用所拥有的数据。

服务可以使用三种策略来访问单体应用的数据：

* 调用单体应用提供的远程API
* 直接访问单体应用的数据库
* 维护自己的数据副本，并与单体应用的数据库同步

胶水代码有时被称为反腐败层。 这是因为胶水代码阻止了新服务的域模型被遗留的单体应用的域模型的概念污染。 胶水代码在两个不同的模型之间进行转换。 术语“反腐败层”首先出现在由埃里克·埃文斯所写的必读书《[Domain Driven Design](https://domainlanguage.com/ddd/)》中，随后在一个[白皮书](http://domainlanguage.com/ddd-resources/ddd-surrounded-by-legacy-software/)中精炼。 开发反腐败层可能是一项不小的工作。 但是，如果你想以自己的方式从地狱中逃出的话，这是必不可少的。

将新功能实现为轻量级服务具有几个好处。 它防止单体应用变得更加难以管理。 该服务可以独立于单体应用开发，部署和扩展。 对于您创建的每个新服务，您都会体验到微服务架构的优势。

然而，这种方法没有解决单体应用的问题。 要解决这些问题，你需要打破巨石。 让我们看看这样做的策略。

## 策略2 - 拆分前端和后端

缩小单体应用程序的策略是将表示层与业务逻辑层和数据访问层分离。 典型的企业应用程序由至少三种不同类型的组件组成：

* 表示层 - 处理HTTP请求并实现（REST）API或基于HTML的Web UI的组件。 在具有复杂用户界面的应用程序中，表示层通常是大量代码。
* 业务逻辑层 - 作为应用程序核心并实现业务规则的组件。
* 数据访问层 - 访问基础结构组件（如数据库和消息代理）的组件。

通常，在表示层逻辑与业务数据访问逻辑之间存在清晰的分界。 业务层，有一个粗粒度的API，其由一个或多个封装业务逻辑的门面组成。 这个API是一个自然缝，您可以沿着这个缝将整个单体应用分割成两个较小的应用程序。 一个应用程序包含表示层。 另一个应用程序包含业务和数据访问逻辑。 分割后，表示层逻辑应用程序对业务逻辑应用程序进行远程调用。 下图显示了重构之前和之后的架构。

![diagram](https://cdn.wp.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part7-refactoring.png)

以这种方式分割整体有两个主要好处。 它使您能够独立于彼此开发，部署和扩展这两个应用程序。 特别地，其允许表示层开发者在用户界面上快速迭代，并且容易执行A|B测试。 这种方法的另一个好处是，它暴露了一个远程API，可以由您开发的微服务调用。

然而，这种策略只是部分解决方案。 很可能分割后的应用程序仍是一个难以管理的单体应用。 您需要使用第三个策略来消除剩余的单体。

## 战略3 - 提取服务

第三个重构策略是将单体应用中的现有模块转换为独立的微服务。 每次你提取一个模块，并把它变成一个服务，这个单体收缩。 一旦你完成足够多的模块的转换，这个单体应用将不再是一个问题。 它或者完全消失，或者变得足够小，成为另一个服务。

### 确定将模块转换为服务的优先级

一个大的，复杂的单体应用程序包括几十或几百个模块，所有这些模块都是需要提取的候选。确定首先转换哪些模块通常是具有挑战性的。一个好的方法是从一些容易提取的模块开始。这将给你提供微服务的经验，特别是提取过程。之后，你应该提取那些将给你带来最大好处的模块。

将模块转换为服务通常是耗时的。应该对所有模块按抽取后给你带来的收益排序。提取频繁变化的模块通常是有益的。将模块转换为服务后，您可以独立于单体应用开发和部署模块，这将加速开发。

提取具有明显不同于其余部分的资源需求的模块也是有益的。例如，将具有内存数据库的模块转换为服务是有用的，可以将服务部署在具有大量内存的主机上。类似地，可以提取计算密集的模块，然后可以部署在具有大量CPU的主机上。通过将具有特定资源需求的模块转换为服务，您可以使您的应用程序更容易扩展。

当确定提取哪些模块时，查找现有的粗粒边界（即缝）是有用的。它们使得将模块转换为服务变得更容易，更省事。这种边界的一个示例，是仅通过异步消息与应用程序的其余部分通信的模块。将该模块转换成微服务相对省事并且容易。

### 如何提取模块

提取模块的第一步是在模块和单体应用之间定义粗粒度接口。它很可能是一个双向API，因为这个单体应用将需要服务拥有的数据，反之亦然。由于模块和应用程序的其余部分之间的依赖性和细粒度的交互模式，实现这样的API通常是具有挑战性的。使用域模型模式实现的业务逻辑对于重构是特别具有挑战性的，因为领域模型类之间存在大量关联。您经常需要对这些重要的代码进行更改以打破这些依赖关系。下图显示了重构。

一旦你实现了粗粒度接口，你就可以将模块转换为独立服务。为此，您必须编写代码以使单体应用和服务通过使用进程间通信（IPC）机制的API进行通信。下图显示重构之前，期间和之后的体系结构。

![diagram](https://cdn.wp.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part7-extract-module-763x1024.png)

在本示例中，模块Z是要提取的候选模块。它的组件由模块X使用，它使用模块Y。第一个重构步骤是定义一对粗粒度的API。第一个接口是模块X用于调用模块Z的输入接口。第二个接口是模块Z用于调用模块Y的输出接口。

第二重构​​步骤将模块转换为独立服务。输入和输出接口由使用IPC机制的代码实现。您可以通过将模块Z与[Microservice Chassis framework](http://microservices.io/patterns/microservice-chassis.html)框架相结合来构建服务，该框架处理跨服务问题，例如服务发现。

一旦你提取了一个模块，你就拥有了一个服务，可以独立开发，部署和扩展。你甚至可以从头重写服务。在这种情况下，将服务与单体应用集成的API代码成为在两个域模型之间进行转换的反腐败层。每次提取服务时，都会沿着微服务的方向迈出另一步。随着时间的推移，单体应用将缩小，你将有越来越多的微服务。

## 总结

将现有应用程序迁移到微服务的过程是应用程序现代化的一种形式。 您不应该从头重写您的应用程序。 相反，你应该递增地将你的应用程序重构为一组微服务。 有三个策略可以使用：以微服务方式实现新功能; 从业务数据访问组件与呈现组件之间开始分离; 将单体应用中的现有模块转换为服务。 随着时间的推移，微服务的数量将会增长，您的开发团队的敏捷性和速度将会增加。
